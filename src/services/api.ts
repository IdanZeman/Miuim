import { supabase } from '../lib/supabase';
import { SchedulingConstraint, Absence, Equipment, HourlyBlockage, DailyPresence } from '@/types';
import { mapAbsenceFromDB, mapAbsenceToDB, mapEquipmentFromDB, mapEquipmentToDB, mapHourlyBlockageFromDB, mapHourlyBlockageToDB, mapConstraintFromDB, mapConstraintToDB, mapUnifiedPresenceToDB } from './mappers';

// Constraints
export const fetchConstraints = async (organizationId: string): Promise<SchedulingConstraint[]> => {
    const { data, error } = await supabase
        .from('scheduling_constraints')
        .select('*')
        .eq('organization_id', organizationId);

    if (error) throw error;

    return data.map(mapConstraintFromDB);
};

export const addConstraint = async (constraint: Omit<SchedulingConstraint, 'id'>) => {
    const dbConstraint = mapConstraintToDB(constraint as SchedulingConstraint);
    delete (dbConstraint as any).id;

    const { data, error } = await supabase
        .from('scheduling_constraints')
        .insert([dbConstraint])
        .select()
        .single();

    if (error) throw error;

    return mapConstraintFromDB(data);
};

export const deleteConstraint = async (id: string) => {
    const { error } = await supabase
        .from('scheduling_constraints')
        .delete()
        .eq('id', id);

    if (error) throw error;
};

// Absences CRUD
export const fetchAbsences = async (organizationId: string): Promise<Absence[]> => {
    const { data, error } = await supabase
        .from('absences')
        .select('*')
        .eq('organization_id', organizationId);

    if (error) throw error;

    return data.map(mapAbsenceFromDB);
};

export const addAbsence = async (absence: Omit<Absence, 'id'>) => {
    // We need an ID for mapAbsenceToDB even if it's Omit<..., 'id'>, 
    // but insert doesn't strictly need it if generated by DB.
    // To be safe and reuse mapper, we cast.
    const dbAbsence = mapAbsenceToDB(absence as Absence);
    delete (dbAbsence as any).id; // Let DB generate

    const { data, error } = await supabase
        .from('absences')
        .insert([dbAbsence])
        .select()
        .single();

    if (error) throw error;

    return mapAbsenceFromDB(data);
};

export const updateAbsence = async (absence: Absence) => {
    const dbAbsence = mapAbsenceToDB(absence);
    const { id, ...updateData } = dbAbsence as any;

    const { error } = await supabase
        .from('absences')
        .update(updateData)
        .eq('id', absence.id);

    if (error) throw error;
};

export const deleteAbsence = async (id: string) => {
    const { error } = await supabase
        .from('absences')
        .delete()
        .eq('id', id);

    if (error) throw error;
};
// Unified Presence
export const upsertUnifiedPresence = async (updates: DailyPresence[]) => {
    if (updates.length === 0) return;

    const dbPayloads = updates.map(mapUnifiedPresenceToDB);
    const { error } = await supabase
        .from('unified_presence')
        .upsert(dbPayloads, { onConflict: 'person_id,date' });

    if (error) throw error;
};

export const updatePresence = async (presence: DailyPresence) => {
    const { error } = await supabase
        .from('unified_presence')
        .upsert(mapUnifiedPresenceToDB(presence), { onConflict: 'person_id,date' });

    if (error) throw error;
};

// Hourly Blockages CRUD
export const fetchHourlyBlockages = async (organizationId: string): Promise<HourlyBlockage[]> => {
    const { data, error } = await supabase
        .from('hourly_blockages')
        .select('*')
        .eq('organization_id', organizationId);

    if (error) throw error;

    return data.map(mapHourlyBlockageFromDB);
};

export const addHourlyBlockage = async (block: Omit<HourlyBlockage, 'id'>) => {
    // Generate UUID if not using backend defaults, but let's assume we pass one or let DB generate.
    // Assuming backend generates ID if omitted, but mapper expects ID. 
    // We can cast like we did for Absence or just pass it.

    const dbBlock = mapHourlyBlockageToDB(block as HourlyBlockage);
    delete (dbBlock as any).id;

    const { data, error } = await supabase
        .from('hourly_blockages')
        .insert([dbBlock])
        .select()
        .single();

    if (error) throw error;

    return mapHourlyBlockageFromDB(data);
};

export const updateHourlyBlockage = async (block: HourlyBlockage) => {
    const dbBlock = mapHourlyBlockageToDB(block);
    const { id, ...updateData } = dbBlock as any;

    const { error } = await supabase
        .from('hourly_blockages')
        .update(updateData)
        .eq('id', block.id);

    if (error) throw error;
};

export const deleteHourlyBlockage = async (id: string) => {
    const { error } = await supabase
        .from('hourly_blockages')
        .delete()
        .eq('id', id);

    if (error) throw error;
};
