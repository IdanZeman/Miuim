import { supabase } from '../lib/supabase';
import { SchedulingConstraint, Absence, Equipment, HourlyBlockage } from '@/types';
import { mapAbsenceFromDB, mapAbsenceToDB, mapEquipmentFromDB, mapEquipmentToDB, mapHourlyBlockageFromDB, mapHourlyBlockageToDB } from './mappers';

// Constraints
export const fetchConstraints = async (organizationId: string): Promise<SchedulingConstraint[]> => {
    const { data, error } = await supabase
        .from('scheduling_constraints')
        .select('*')
        .eq('organization_id', organizationId);
    
    if (error) throw error;
    
    return data.map((c: any) => ({
        id: c.id,
        personId: c.person_id,
        teamId: c.team_id,
        roleId: c.role_id,
        type: c.type,
        taskId: c.task_id,
        startTime: c.start_time,
        endTime: c.end_time,
        organization_id: c.organization_id,
        description: c.description
    }));
};

export const addConstraint = async (constraint: Omit<SchedulingConstraint, 'id'>) => {
    const sanitizeUuid = (id: string | undefined | null) => (id && id.length > 0 ? id : null);

    const dbConstraint = {
        person_id: sanitizeUuid(constraint.personId),
        team_id: sanitizeUuid(constraint.teamId),
        role_id: sanitizeUuid(constraint.roleId),
        type: constraint.type,
        task_id: sanitizeUuid(constraint.taskId),
        start_time: constraint.startTime,
        end_time: constraint.endTime,
        organization_id: constraint.organization_id,
        description: constraint.description
    };

    const { data, error } = await supabase
        .from('scheduling_constraints')
        .insert([dbConstraint])
        .select()
        .single();
    
    if (error) throw error;

    return {
        id: data.id,
        personId: data.person_id,
        teamId: data.team_id,
        roleId: data.role_id,
        type: data.type,
        taskId: data.task_id,
        startTime: data.start_time,
        endTime: data.end_time,
        organization_id: data.organization_id,
        description: data.description
    };
};

export const deleteConstraint = async (id: string) => {
    const { error } = await supabase
        .from('scheduling_constraints')
        .delete()
        .eq('id', id);
    
    if (error) throw error;
};

// Absences CRUD
export const fetchAbsences = async (organizationId: string): Promise<Absence[]> => {
    const { data, error } = await supabase
        .from('absences')
        .select('*')
        .eq('organization_id', organizationId);
    
    if (error) throw error;
    
    return data.map(mapAbsenceFromDB);
};

export const addAbsence = async (absence: Omit<Absence, 'id'>) => {
    // We need an ID for mapAbsenceToDB even if it's Omit<..., 'id'>, 
    // but insert doesn't strictly need it if generated by DB.
    // To be safe and reuse mapper, we cast.
    const dbAbsence = mapAbsenceToDB(absence as Absence);
    delete (dbAbsence as any).id; // Let DB generate

    const { data, error } = await supabase
        .from('absences')
        .insert([dbAbsence])
        .select()
        .single();
    
    if (error) throw error;

    return mapAbsenceFromDB(data);
};

export const updateAbsence = async (absence: Absence) => {
    const dbAbsence = mapAbsenceToDB(absence);
    const { id, ...updateData } = dbAbsence as any;
    
    const { error } = await supabase
        .from('absences')
        .update(updateData)
        .eq('id', absence.id);
    
    if (error) throw error;
};

export const deleteAbsence = async (id: string) => {
    const { error } = await supabase
        .from('absences')
        .delete()
        .eq('id', id);
    
    if (error) throw error;
};
// Daily Presence
export const upsertDailyPresence = async (updates: any[]) => {
    if (updates.length === 0) return;

    const { error } = await supabase
        .from('daily_presence')
        .upsert(updates, { onConflict: 'date,person_id,organization_id' });
    
    if (error) throw error;
};

// Hourly Blockages CRUD
export const fetchHourlyBlockages = async (organizationId: string): Promise<HourlyBlockage[]> => {
    const { data, error } = await supabase
        .from('hourly_blockages')
        .select('*')
        .eq('organization_id', organizationId);
    
    if (error) throw error;
    
    return data.map(mapHourlyBlockageFromDB);
};

export const addHourlyBlockage = async (block: Omit<HourlyBlockage, 'id'>) => {
    // Generate UUID if not using backend defaults, but let's assume we pass one or let DB generate.
    // Assuming backend generates ID if omitted, but mapper expects ID. 
    // We can cast like we did for Absence or just pass it.
    
    const dbBlock = mapHourlyBlockageToDB(block as HourlyBlockage);
    delete (dbBlock as any).id; 

    const { data, error } = await supabase
        .from('hourly_blockages')
        .insert([dbBlock])
        .select()
        .single();
    
    if (error) throw error;

    return mapHourlyBlockageFromDB(data);
};

export const updateHourlyBlockage = async (block: HourlyBlockage) => {
    const dbBlock = mapHourlyBlockageToDB(block);
    const { id, ...updateData } = dbBlock as any;

    const { error } = await supabase
        .from('hourly_blockages')
        .update(updateData)
        .eq('id', block.id);
    
    if (error) throw error;
};

export const deleteHourlyBlockage = async (id: string) => {
    const { error } = await supabase
        .from('hourly_blockages')
        .delete()
        .eq('id', id);
    
    if (error) throw error;
};
