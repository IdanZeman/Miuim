import { supabase } from '../lib/supabase';
import { SchedulingConstraint, Absence, Equipment, HourlyBlockage } from '@/types';
import { mapAbsenceFromDB, mapAbsenceToDB, mapEquipmentFromDB, mapEquipmentToDB, mapHourlyBlockageFromDB, mapHourlyBlockageToDB, mapConstraintFromDB, mapConstraintToDB, mapDailyPresenceFromDB } from './mappers';

// Constraints
export const fetchConstraints = async (organizationId: string): Promise<SchedulingConstraint[]> => {
    const { data, error } = await supabase
        .from('scheduling_constraints')
        .select('*')
        .eq('organization_id', organizationId);

    if (error) throw error;

    return data.map(mapConstraintFromDB);
};

export const addConstraint = async (constraint: Omit<SchedulingConstraint, 'id'>) => {
    const dbConstraint = mapConstraintToDB(constraint as SchedulingConstraint);
    delete (dbConstraint as any).id;

    const { data, error } = await supabase
        .from('scheduling_constraints')
        .insert([dbConstraint])
        .select()
        .single();

    if (error) throw error;

    return mapConstraintFromDB(data);
};

export const deleteConstraint = async (id: string) => {
    const { error } = await supabase
        .from('scheduling_constraints')
        .delete()
        .eq('id', id);

    if (error) throw error;
};

// Absences CRUD
export const fetchAbsences = async (organizationId: string): Promise<Absence[]> => {
    const { data, error } = await supabase
        .from('absences')
        .select('*')
        .eq('organization_id', organizationId);

    if (error) throw error;

    return data.map(mapAbsenceFromDB);
};

export const addAbsence = async (absence: Omit<Absence, 'id'>) => {
    // We need an ID for mapAbsenceToDB even if it's Omit<..., 'id'>, 
    // but insert doesn't strictly need it if generated by DB.
    // To be safe and reuse mapper, we cast.
    const dbAbsence = mapAbsenceToDB(absence as Absence);
    delete (dbAbsence as any).id; // Let DB generate

    const { data, error } = await supabase
        .from('absences')
        .insert([dbAbsence])
        .select()
        .single();

    if (error) throw error;

    return mapAbsenceFromDB(data);
};

export const updateAbsence = async (absence: Absence) => {
    const dbAbsence = mapAbsenceToDB(absence);
    const { id, ...updateData } = dbAbsence as any;

    const { error } = await supabase
        .from('absences')
        .update(updateData)
        .eq('id', absence.id);

    if (error) throw error;
};

export const deleteAbsence = async (id: string) => {
    const { error } = await supabase
        .from('absences')
        .delete()
        .eq('id', id);

    if (error) throw error;
};
// Daily Presence
export const upsertDailyPresence = async (updates: any[]) => {
    if (updates.length === 0) return;

    const { error } = await supabase
        .from('daily_presence')
        .upsert(updates, { onConflict: 'date,person_id,organization_id' });

    if (error) throw error;
};

export const fetchDailyPresence = async (organizationId: string, startDate?: string, endDate?: string): Promise<import('@/types').DailyPresence[]> => {
    // Fetch ALL records using pagination to bypass PostgREST's 1000 row limit
    let allData: any[] = [];
    let from = 0;
    const pageSize = 1000;
    let hasMore = true;

    while (hasMore) {
        let query = supabase
            .from('daily_presence')
            .select('*', { count: 'exact' })
            .eq('organization_id', organizationId)
            .range(from, from + pageSize - 1);

        if (startDate) query = query.gte('date', startDate);
        if (endDate) query = query.lte('date', endDate);

        const { data, error, count } = await query;
        
        if (error) throw error;
        
        if (data && data.length > 0) {
            allData = [...allData, ...data];
            from += pageSize;
            hasMore = data.length === pageSize && (!count || allData.length < count);
        } else {
            hasMore = false;
        }
    }

    return allData.map(mapDailyPresenceFromDB);
};

// Hourly Blockages CRUD
export const fetchHourlyBlockages = async (organizationId: string): Promise<HourlyBlockage[]> => {
    const { data, error } = await supabase
        .from('hourly_blockages')
        .select('*')
        .eq('organization_id', organizationId);

    if (error) throw error;

    return data.map(mapHourlyBlockageFromDB);
};

export const addHourlyBlockage = async (block: Omit<HourlyBlockage, 'id'>) => {
    // Generate UUID if not using backend defaults, but let's assume we pass one or let DB generate.
    // Assuming backend generates ID if omitted, but mapper expects ID. 
    // We can cast like we did for Absence or just pass it.

    const dbBlock = mapHourlyBlockageToDB(block as HourlyBlockage);
    delete (dbBlock as any).id;

    const { data, error } = await supabase
        .from('hourly_blockages')
        .insert([dbBlock])
        .select()
        .single();

    if (error) throw error;

    return mapHourlyBlockageFromDB(data);
};

export const updateHourlyBlockage = async (block: HourlyBlockage) => {
    const dbBlock = mapHourlyBlockageToDB(block);
    const { id, ...updateData } = dbBlock as any;

    const { data, error } = await supabase
        .from('hourly_blockages')
        .update(updateData)
        .eq('id', block.id)
        .select()
        .single();

    if (error) throw error;
    
    return mapHourlyBlockageFromDB(data);
};

export const deleteHourlyBlockage = async (id: string) => {
    const { error } = await supabase
        .from('hourly_blockages')
        .delete()
        .eq('id', id);

    if (error) throw error;
};
